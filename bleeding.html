<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>image viewer</title>
  </head>
  <body>
		<style>
		  body .hidden {
		    display: none;
		  }
      .smaller {
				font-size: small;
			}		
		
		  .monospace {
				font-family: monospace;
			}
			
			.indent1 {
				margin-left: 10px;
			}
			.indent2 {
				margin-left: 25px;
			}
			.indent3 {
			  margin-left: 35px;
			}
		
			a:visited {
				color: #0000EE;
			}
			a:hover {
			  color: #551A8B;
			}
			a:active {
				color: #551A8B;
			}
			
			.black-link {
			  color: black;
			}
			.black-link:visited {
			  color: black;
			}
			.black-link:hover {
			  color: #551A8B;
			}
			.black-link:active {
			  color: #551A8B;
			}
			
			.gray-link {
			  color: gray;
			}
			.gray-link:visited {
			  color: gray;
			}
			.gray-link:hover {
			  color: #551A8B;
			}
			.gray-link:active {
			  color: #551A8B;
			}
		
			#bg { /* Workaround to prevent fullscreen from changing page color. */
				/* Color. */
				background-color: white;
				/* All the way in the back. */
				position: absolute;
				z-index: -9001;
				/* Take up the whole page. */
				top: 0;
				left: 0;
				height: 100%;
				width: 100%;
			}
			
			#title {
				/* Keep it from having infinite width. */
				display: inline-block;
				/* Stay away from the sides in fullscreen. */
				margin-left: 20px;
			}
			#title h1 {
				/* This can't move, so it should be covered by the image if necessary.
				If the main link had this it wouldn't be clickable. */
				position: relative;
		    z-index: -2;
				/* Positioning */
				margin: 40px 0 20px 0;
		  }
			
			.box {
			  /* Draggy. */
				position: absolute;
				cursor: move;
				/* Appearance */
				border: 1px solid lightgray;
				display: inline-block;
				padding: 0 5px 5px 5px;
			}
			
			#edit-folder {
			  padding-top: 5px;
			  background-color: white;
			}
			
			.close-link {
			  float: right;
			}
			
			.filename {
			  background-color: white;
			}
			
			#reset {
			  margin-left: 10px;
			  background-color: white;
			}
			
			#timer {
				/* Make it stand out a bit. */
				margin-left: 5px;
				font-size: 22px;
				background-color: white;
			}
			
			#display {
				/* Don't cover up anything else, except the title sometimes. */
				position: absolute;
				z-index: -1;
				background-color: transparent;
				/* Take up the whole page. */
				top: 0;
				left: 0;
				height: 100%;
				width: 100%;
				background-size: auto 100%;
				/* Center the background image. */
				background-position: center;
				/* Don't use the image as a tile. */
				background-repeat: no-repeat;
			}
			
			.tag-box {
			  font-size: 12px;
			  font-family: monospace;
			  width: 200px;
			  height: 80px;
			  overflow-y: auto;
			  resize: none;
			  margin-top: 5px;
			}
			
			.tag-list {
			  list-style-type: none;
			  margin-top: 10px;
			  padding-left: 0;
			  width: 307px;
			}
			
			.tag-list li {
			  font-size: 12px;
			  font-family: monospace;
			  display: inline-block;
			}
			text {
			  cursor: pointer;
			}
			#edit-tags {
			}
			
			.download-config {
			  background: white;
			}
		</style>
		<div id="bg"></div>
		
		<div id="display"></div>
		
		<a id="title" class="black-link" href="https://www.github.com/ooorel/iv"
		   target="_blank" rel="noopener noreferrer">
		  <h1>iv</h1>
		</a><br>
		
		<div id="box" class="box">
			<a id="hide" class="smaller link hide-link" href="#/">[hide]</a>
			<a id="fullscreen" class="smaller link" href="#/">[toggle fullscreen]</a><br>
			<span class="hide-section">
			  <br>
			  <input id="upload" type="file" webkitdirectory directory multiple><br>
			  <span id="hidden-to-start-filter-section" class="hidden">
			    <text>Filter images</text>
			    <a id="hide-filter" class="smaller hide-link" href="#/">[show]</a>
			    <text>:</text><br>
			    <span class="hide-filter-section hidden">
			      <text id="filter-count" class="indent1">[num. images here, upload font]</text><br>
			      <textarea id="tag-search" class="cancel-key tag-box indent1" spellcheck="false"
			        placeholder="Only display images with these tags.
			        (No tags selected)"></textarea>
			      <ul id="tags-list" class="tag-list"></ul>
			      <a id="open-edit-folder" href="#/" class="indent1 smaller box-link">Edit folder</a>
			      <a id="open-edit-tags" href="#/" class="indent1 smaller box-link">Edit tags</a><br>
			    <br>
					</span>
		      <br>
		      </span>
			</span><br>
			<span id="hidden-to-start-file-section" class="hidden">
			<text id="filename" class="smaller filename"></text><br>
			<a id="previous" class="link" href="#/">previous</a>
			<a id="next" class="link" href="#/">next</a><br>
			<br>
			</span><br>
			<a id="reset" class="gray-link" href="#/">&#8635;</a>
			<a id="timer" class="gray-link" href="#/">10:00</a><br>
			<span class="hide-section">
			<br >
				<text>Options</text>
				<a id="hide-options" class="smaller hide-link" href="#/">[show]</a>
				<text>:</text><br>
				<span class="hide-options-section hidden">
				  <text class="indent1">Length:</text><br>
					  <input id="timer-hr" type="text" class="cancel-key indent2 monospace"
					    placeholder="00" size="2" maxlength="2" autocomplete="off"> :
					  <input id="timer-min" type="text" class="cancel-key monospace"
					    placeholder="10" size="2" maxlength="2" autocomplete="off"> :
					  <input id="timer-sec" type="text" class="cancel-key monospace"
					    placeholder="00" size="2" maxlength="2" autocomplete="off"><br>
				  <input id="prevent-recent-repeats" type="checkbox"
				    class="indent1" checked>Prevent recent repeats<br> 
				  <input id="hide-every-other" type="checkbox"
				    class="indent1">Hide every other image<br>    
					<input id="display-new" type="checkbox"
					  class="indent1" checked>Display new images on skip<br>
				  <text class="indent1">When timer ends:</text><br>
				    <input id="on-end-display-new" type="checkbox"
				      class="indent2" checked>display new image<br>
					  <input id="on-end-reset" type="checkbox"
					    class="indent2" checked>reset time &#8635;<br>
					    <input id="on-end-count" type="checkbox"
					      class="indent3" checked>start counting down<br>
					<input id="display-in-file-order" class="file-sort" type="checkbox"
					  class="indent1">Display images in file order</input><br>
					  <text class="indent2">Property:</text><br>
					    <input type="radio" class="file-sort indent3" name="file-property" value="name" checked> name<br>
					    <input type="radio" class="file-sort indent3" name="file-property" value="type"> type<br>
					    <input type="radio" class="file-sort indent3" name="file-property" value="path"> path<br>
					    <input type="radio" class="file-sort indent3" name="file-property" value="size"> size<br>
					    <input type="radio" class="file-sort indent3" name="file-property" value="lastModified"> last modified<br>
					  <text class="indent2">Order:</text><br>
					    <input type="radio" class="file-sort indent3" name="file-order" value="ascending" checked> ascending<br>
					    <input type="radio" class="file-sort indent3" name="file-order" value="descending"> descending<br>
						<a href="#/" class="jump-to-start indent2">Jump to start</a><br>    
						
				</span>
			</span>
		</div>
		<div id="edit-folder" class="hidden box">
		  <text>Edit folder properties:</text>
		  <a id="close-edit-folder" href="#/" class="close-link">x</a><br>
		  <br>
		  <text>Folder name:</text>
		  <input id="name" type="text" class="cancel-key indent1 folder-setting"
					    placeholder="iv" size="8" autocomplete="off"><br>
		  <br>
		  <text>Cover Image:</text>
		  <input id="cover-image" type="text" class="cancel-key indent1 folder-setting"
					    placeholder="none" size="8" autocomplete="off"><br>
			<br>
		  <a id="download-folder" href="#/" class="download-config smaller">
		    Save settings</a>
		</div>
		<div id="edit-tags" class="hidden box">
		  <text>Tag images:</text>
		  <a id="close-edit-tags" href="#/" class="close-link">x</a><br>
		  <text id="tags-filename" class="smaller filename">current/image/name</text><br>
		  <text id="untagged-images" class="smaller"># untagged images</text><br>
		    <textarea id="edit-tag-search" class="cancel-key tag-box indent1" spellcheck="false"
			    placeholder="The current image's tags. (There are none)"></textarea>
			    <ul id="edit-tags-list" class="tag-list"></ul>
		  <a id="tags-previous" class="link" href="#/">previous</a>
			<a id="tags-next" class="link" href="#/">next</a><br>
			<a id="download-tags" class="download-config smaller" href="#/">
		    Save settings</a><br>
		  <br>
		  <text>Display order</text>
		  <a id="hide-tags-options" class="smaller link hide-link" href="#/">[show]</a>
		  <text>:</text><br>
		  <span class="hide-tags-options-section hidden">
		    <text class="indent1">Sort by</text><br>
			  <text class="indent2">file property:</text><br>
			    <input type="radio" class="tags-file-sort indent3" name="tags-file-property" value="name" checked> name<br>
			    <input type="radio" class="tags-file-sort indent3" name="tags-file-property" value="type"> type<br>
			    <input type="radio" class="tags-file-sort indent3" name="tags-file-property" value="path"> path<br>
			    <input type="radio" class="tags-file-sort indent3" name="tags-file-property" value="size"> size<br>
			    <input type="radio" class="tags-file-sort indent3" name="tags-file-property" value="lastModified"> last modified<br>
			  <text class="indent2">order:</text><br>
			    <input type="radio" class="tags-file-sort indent3" name="tags-file-order" value="ascending" checked> ascending<br>
			    <input type="radio" class="tags-file-sort indent3" name="tags-file-order" value="descending"> descending<br>
				<a href="#/" class="jump-to-start indent2">Jump to start</a><br>
		  </span>
		</div>
		<div id="ghost" class="hidden box"></div>
		<a id="download-link"></a>
			
		<script type="text/javascript">
			"use strict;"
			{
			  let testing = true;
			  
			  function print(x) {
			    if (testing) {
			      console.log(x);
			    }
			  }
			  
				function s_print(x) { // strong print
					console.log(x);
				}
			  
			  function printTest(t) {
			    testing = t;
			    s_print('Printing tests: ' + t);
			  }
			}
			
			function $(str) {
			  return document.getElementById(str);
			}
			
			function $c(str) {
			  return Array.prototype.slice.call(document.getElementsByClassName(str));
			}
			
			function $n(str) {
			  return Array.prototype.slice.call(document.getElementsByName(str));
			}
			
			// Assign events to multiple objects at once. (does not hoist)
			Array.prototype.listen = function(event, body) {
        this.forEach((el)=>{
          el.addEventListener(event, body);
        });
      }

			// Hiding things. --------------------------------------------------------
			// Hide the non-main menus.
			$c('box-link').listen('click', (e)=>{
			  let box = $(e.target.id.slice(5));
			  if (elDisplay(box) === 'none') {
			    d_setVisible(box, true);
			  }
			  else {
			    d_setVisible(box, false);
			  }
			});
			$c('close-link').listen('click', (e)=>{
			  let box = $(e.target.id.slice(6));
			  d_setVisible(box, false);
			});
			
			function elDisplay(el) {
			  return window.getComputedStyle(el)['display'];
			}
			
			// Hide sections within the main menu.
			$c('hide-link').listen('click', (e)=>{
			  let id = e.target.id,
			      label = $(id).innerHTML;
			  if (label === '[hide]') {
			    d_setSectionVisible(id, false);
			  }
			  else {
			    d_setSectionVisible(id, true);
			  }
			});
			
			function d_setSectionVisible(id, value) {
			  let link = $(id),
			      sections = $c(id + '-section');
			  // Hide or show content.
			  sections.forEach((el)=>{
			    d_setVisible(el, value);
			  });
			  // Update label.
			  if (value) {
			    link.innerHTML = '[hide]';
			  }
			  else {
			    link.innerHTML = '[show]';
			  }
			  print('d_setSectionVisible(' + id + ', ' + value + ')');
			}
			
			function d_setVisible(el, value) {
				if (typeof(value) === 'string') {
					el.style.display = value;
				}
				else {
					el.style.display = value ? 'inline-block' : 'none';
				}
				return value;
			}
			
			// Draggable divs --------------------------------
			//d_draggable('box');
			$c('box').forEach((el)=>{
			  d_draggable(el.id);
			});
			
			function d_draggable(id) {
				let posx,
						posy,
						xOffset,
						yOffset,
						el = $(id),
						ghost = $('ghost');
						
				el.addEventListener('mousedown', click);
				
				function click(e) {
					e = e || window.event;
					// Make sure this doesn't gank everything in the div.
					let nodeType = e.explicitOriginalTarget.nodeName;
					if (nodeType === 'TEXTAREA' ||
					    nodeType === '#text' ||
					    nodeType === "INPUT") {
					  return false;
					}
					// Get initial mouse position.
					posx = e.clientX;
					posy = e.clientY;
					// Get offset from top left corner.
					let rect = el.getBoundingClientRect();
					xOffset = posx - rect.x;
					yOffset = posy - rect.y;
					// Set ghost size.
					ghost.style.paddingRight = rect.width + 'px';
					ghost.style.height = rect.height + 'px';
					// Show the ghost.
					d_setVisible(ghost, true);
					// And hide the box.
					d_setVisible(el, false);
					// Don't want to be running this code all the time.
					document.onmouseup = close;
					document.onmousemove = drag;
					
					print('clicked box');
				}
				
				function drag(e) {
					e = e || window.event;
					e.preventDefault();
					// Update mouse position.
					posx = e.clientX;
					posy = e.clientY;
					// Move the ghost preview.
					ghost.style.left = (posx - xOffset) + 'px';
					ghost.style.top = (posy - yOffset) + 'px';
					
					print('dragging box');
				}
				
				function close() {
					// Hide the ghost.
					d_setVisible(ghost, false);
					// Show the box.
					d_setVisible(el, true);
					// Set the element's new position.
					el.style.left = (posx - xOffset) + 'px';
					el.style.top = (posy - yOffset) + 'px';
					// Stop doing things when the mouse is released.
					document.onmouseup = null;
					document.onmousemove = null;
					
					print('let go of box');
				}
			}
			
			// Fullscreen -----------------------------------------------
			function requestFullscreen(el) {
				if(el.requestFullscreen)
					el.requestFullscreen();
				else if(el.mozRequestFullScreen)
					el.mozRequestFullScreen();
				else if(el.webkitRequestFullscreen)
					el.webkitRequestFullscreen();
				else if(el.msRequestFullscreen)
					el.msRequestFullscreen();
			}
			
			function exitFullscreen() {
				if(document.exitFullscreen)
					document.exitFullscreen();
				else if(document.mozCancelFullScreen)
					document.mozCancelFullScreen();
				else if(document.webkitExitFullscreen)
					document.webkitExitFullscreen();
				else if(document.msExitFullscreen)
					document.msExitFullscreen();
			}
			
			function isFullscreen() {
				var full_screen_element = document.fullscreenElement ||
				    document.webkitFullscreenElement ||
				    document.mozFullScreenElement ||
				    document.msFullscreenElement ||
				    null;
	
				// If no element is in full-screen
				if (full_screen_element === null) {
					return false;
				}
				else {
					return true;
				}
			}
			
			// Fullscreen has to be triggered by a click, idk
			$('fullscreen').onclick = ()=>{
				if (isFullscreen()) {
					exitFullscreen();
				}
				else {
					requestFullscreen(document.body);
				}
			}
			
			// Timer. ----------------------------------------------------------------
			{
			  let counting = false,
			      hidLastImage = false,
			      i;
			  
			  $('reset').onclick = d_reset;
			  
			  $('timer').onclick = ()=>{
			    if (!counting) {
			      d_resume();
			    }
			    else {
			      d_pause();
			    }
			  }
			  
			  function d_resume(){
			    // Timer is counting.
		      d_startCount('resume');
		      counting = true;
		      // Change colors to something hard to miss.
		      $('timer').className = 'black-link';
		      $('reset').className = '';
			  }
			  
			  function d_pause(){
			    // Timer is just there.
	        d_endCount('pause');
	        counting = false;
	        // Change colors to something easy to ignore.
	        $('timer').className = 'gray-link';
	        $('reset').className = 'gray-link';
			  }
			  
			  function d_reset() {
			    d_pause();
			    d_displayTimer(arrToStr(option('timer-length')));
			  }
			  
			  // count
			  function d_endCount(from) { // reset pause
			    // Stop counting.
			    clearInterval(i);
			    if (from === 'reset') {
			      if (option('on-end-reset')) {
			        // Reset timer.
			        d_displayTimer(arrToStr(option('timer-length')));
			        // Start counting down.
			        if (option('on-end-count')) {
			          // Display a new image, but don't start counting until it loads.
			          if (option('on-end-display-new')) {
			            d_next('', ()=>{
			              d_startCount('reset');
			              },
			              'reset');
			          }
			          // Count down without changing the display.
			          else {
			            print('else');
			            d_startCount('reset');
			          }
			        }
			      }
			      else {
			        // Just display a new image.
			        d_next();
			      }
			    }
			  }
			  
			  function d_startCount(from) {
			    let goal;
			    if (from === 'reset') {
			      goal = getGoal(option('timer-length'));
			    }
			    else {
			      goal = getGoal(strToArr(currentTimer()));
			    }
			    d_count(goal);
			  }
			  
			  function d_count(goal) {
			    // Stop previous countdown.
			    clearInterval(i);
			    // Set function to decrement.
			    i = setInterval(()=>{
			      let remaining = goal - Date.now(),
			          arr = msToArr(remaining),
			          str = arrToStr(arr);
			      d_displayTimer(str);
			      // When the timer reaches zero:
			      if (remaining <= 500) {
			        d_endCount('reset');
			        print('end timer');
			      }
			    }, 225);
			  }
			  
			  function getGoal(arr) {
			    return Date.now() + arrToMs(arr);
			  }
			  
			  // Update timer's display.
			  function d_displayTimer(str) {
			    $('timer').innerHTML = str;
			  }
			  
			  function currentTimer() {
			    return $('timer').innerHTML;
			  }
			  
			  // Convert a time array to a string for display, and vice versa.
			  function strToArr(str) {
			    let arr = str.split(':');
			    if (arr.length < 3) {
			      arr.unshift('00');
			    }
			    return arr;
			  }
			  
			  function arrToStr(arr) {
			    let str = padNum(arr[0]) + ':' + 
			              padNum(arr[1]) + ':' + 
			              padNum(arr[2]);
			    if (str.slice(0, 2) === '00') {
			      str = str.slice(3);
			    }
			    else if (str[0] === '0') {
			      str = str.slice(1);
			    }
			    return str;
			  }
			  
			  // Convert a time array to milliseconds and vice versa.
			  function msToArr(ms) {
			    let sec = Math.floor(ms / 1000),
			        hr,
			        min;
			    hr = Math.floor(sec / 3600);
			    sec -= hr * 3600;
			    min = Math.floor(sec / 60);
			    sec -= min * 60;
			    return [padNum(hr), padNum(min), padNum(sec)];
			  }
			  
			  function padNum(n) {
			    n = Number(n);
			    if (n < 10) {
			      return '0' + n;
			    }
			    else {
			      return '' + n;
			    }
			  }
			  
			  function arrToMs(arr) {
			    return (arr[0] * 60 * 60 * 1000) +
			           (arr[1] * 60 * 1000) +
			           (arr[2] * 1000);
			  }
			  
			  // Fetch settings from Options.
			  function option(id) {
			    if (id === 'timer-length') {
			      return timerLength();
			    }
			    else {
			      return $(id).checked;
			    }
			  }
			  
			  function timerLength() {
			    let hr = $('timer-hr').value || '00',
			        min = $('timer-min').value || '10',
			        sec = $('timer-sec').value || '00',
			        length = [hr, min, sec];
			    return length;
			  }
			}
			
			// File upload and navigation. -------------------------------------------
			
				let upload = [],  // Images user uploads.
				    uploadP = {}, // path: Images in upload with filepath as id.
				    uploadF = [], // filter: This is the collection to sort.
				    history = [], // Record of files user's viewed this session.
						pointer = 0,  // Place in history. 0 is most recent, 1 is 2nd-most.
						hidLastImage = false; // For memory drawing.
			
			  function fetchHistory(pointer) {
			    return history[pointer];
			  }
			
			  function d_archive(file) {
			    history.unshift(file);
			    return file;
			  }
			  
				// Jump to the first index of uploadF
				$c('jump-to-start').listen('click', ()=>{
					d_completeDisplay(uploadF[0], true);
					d_setFileIndex(1);
				});
				
				// Sort uploads whenever the user changes menu.
				$c('file-sort').listen('click', ()=>{
					uploadF = sortUploadsFromMenu('file-property', 'file-order');
					d_setFileIndex(0);
					print('file-sort()');
					print(uploadF);
				});
				
				$c('tags-file-sort').listen('click', ()=>{
					uploadF = sortUploadsFromMenu('tags-file-property', 'tags-file-order');
					d_setFileIndex(0);
					print('tags-file-sort()');
					print(uploadF);
				});
				
				// Sort by file properties pulled from menu.
				function sortUploadsFromMenu(propertyName, orderName) {
					return sortUploads(selectedRadio(propertyName), selectedRadio(orderName));
				}
				
				// Find which radio button in a group is selected.
				function selectedRadio(name) {
					let options = $n(name);
					for (let i in options) {
						let option = options[i];
						if (option.checked) {
							return option.value;
						}
					}
				}
				
			  // Sort by file properties.
			  function sortUploads(parameter, order) {
			    return uploadF.sort(compareFun(parameter, order));
			  }
			  
			  function compareFun(parameter, order) { // screwed by names w/ nums
			    if (order === 'ascending') {
			      order = 1;
			    }
			    else {
			      order = -1;
			    }
			    return (file1, file2)=>{
			      let data1 = fileParameter(file1, parameter),
			          data2 = fileParameter(file2, parameter);
			      if (data1 > data2) {
			        // data2 comes first in alphanumeric order.
			        return 1 * order;
			      }
			      else {
			        return -1 * order;
			      }
			    };
			  }
			  
			  function fileParameter(file, parameter) {
			    if (parameter === 'lastModified') {
			      return file.lastModified;
			    }
			    else if (parameter === 'name') {
			      return file.name;
			    }
			    else if (parameter === 'size') {
			      return file.size;
			    }
			    else if (parameter === 'type') {
			      return file.type;
			    }
			    else if (parameter === 'path') {
			      return file.webkitRelativePath;
			    }
			    else {
			      print('fileParameter() ):');
			    }
			  }
			  
			  // Display an image, update the ui, and archive it for later.
			  function d_completeDisplay(img, doArchive, onload) {
			    d_display(img, onload);
			    d_displayFilename(img);
			    if (doArchive) {
			      d_archive(img);
			    }
			  }
			  
			  // Display an image.
			  function d_display (img, onload) {
			    if (img === '' || img === undefined) { // Clear the display.
			      $('display').style.backgroundImage = '';
			      // Delay tasks.
			      if (typeof(onload) === 'function') {
					      onload();
					  }
			    }
			    else { // Draw the image.
			      let reader = new FileReader();
				    reader.readAsDataURL(img);
				    reader.onload = (e)=>{
					    let url = e.target.result;
					    $('display').style.backgroundImage = 'url(' + url + ')';

					    if (typeof(onload) === 'function') {
					      onload();
					    }
				    };
			    }
			  }
			  
			  function d_displayFilename(img) {
				  let name;
				  if (img === '' || img === undefined) {
				    name = '';
				  }
				  else {
				    name = img.webkitRelativePath;
				    if (name.length > 31) {
				      name = name.slice(0, 25) + '...' + name.slice(-3);
				    }
				  }
				  $('filename').innerHTML = name;
				  $('tags-filename').innerHTML = name;
				}
			
				$('upload').onchange = d_uploadInit; function d_uploadInit(e) {
				  let hasConfig = false;
					upload = Array.from($('upload').files);
					// Make sure there's some data before working.
					if (upload.length > 0) {
						// Show file navigation.
						d_setVisible($('hidden-to-start-file-section'), true);
						// Show filter.
						d_setVisible($('hidden-to-start-filter-section'), true);
					  // Filter out any non-image files.
					  upload.forEach((file, i)=>{
					    let name = file.name;
					    // File isn't an image, remove it.
					    if (!isDisplay(filetype(name))) {
					      upload.splice(i, 1);
					      print('Removed file from display list: ' + name);
					      // File is a config, use it.
					      if (name === 'ivconfig.txt') {
					        print('Found config file!');
					        hasConfig = true;
					        d_readConfig(file, d_configInit);
					      }
					    }
					    // File is an image, store it in a hash for name lookup.
					    else {
					      let path = file.webkitRelativePath;
					      uploadP[path] = file;
					    }
					  })
						// Clone upload to uploadF
						uploadF = upload.slice();
						// Sort uploadF if the folder wants to be fileordered
						if (option('display-in-file-order')) {
							print('This folder wants to be displayed in order of file properties by default.');
							uploadF = sortUploadsFromMenu('file-property', 'file-order');
						}
					}
					if (!hasConfig) {
					  print('No config file found.');
					  // Minimize the filter.
					  d_setSectionVisible('hide-filter', false);
		        // No cover image specified, just display the first.
		        d_completeDisplay(upload[0], true);
					}
					
					print('d_uploadInit()');
					print(upload);
				}
				
				// Run this when a config file is loaded. || Might want to move this away if displays start taking arr
			  function d_configInit() {
			    // Fill out the tag lists.
			    d_syncTagLinks('tags-list', 'tag-search', true);
			    d_syncTagLinks('edit-tags-list', 'edit-tag-search');
			    // Expand filter.
          d_setSectionVisible('hide-filter', true);
          // Update menu, in case they want to edit.
          d_syncEditFolder();
          // There might not have been any images in the upload.
          if (upload.length > 0) {
            // Display an image to start.
            let cover = config('cover-image');
            // Cover image is not provided.
            if (cover === undefined || cover === '') {
              d_completeDisplay(upload[0], true);
            }
            // Cover image is provided as a path.
            else if (isPath(cover)) {
              d_completeDisplay(uploadP[cover], true);
            }
            // Cover image is provided as an index? Nobody's going to use this
            else {
              img = upload[Number(cover)];
              d_completeDisplay(upload[Number(cover)], true);
            }
          }
			  }
				
				// Check if a file is good to display.
				{
				  let valid = ['jpg'.toLocaleUpperCase(),
				               'png'.toLocaleUpperCase(),
				               'jpeg'.toLocaleUpperCase()];
				  function isDisplay(extension) {
				    extension = extension.toLocaleUpperCase();
				    for (i in valid) {
				      let type = valid[i];
				      if (extension === type) {
				        return true;
				      }
				    }
				    return false;
				  }
				}
				
				// Get a file's extension.
				function filetype(name) {
				  return name.split('.').slice(-1)[0];
				}
				
				$('next').onclick = d_next; function d_next(e, onload, from) {
				  if (uploadF.length !== 0) {
				    if (pointer > 0) {
				      d_displayNextHistory(onload);
				    }
				    else {
							if (option('display-in-file-order') ||
							    from === 'tags-next') {
								d_displayFileOrder(onload);
							}
				      else if (option('display-new') ||
				          from === 'reset' && option('on-end-display-new')) {
				        if (option('hide-every-other')) {
				          if (hidLastImage) {
				            d_displayRandom(onload);
				            hidLastImage = false;
				          }
				          else {
				            d_displayBlank(onload);
				            hidLastImage = true;
				          }
				        }
				        else {
				          d_displayRandom(onload);
				        }
				      }
				      else {
				        if (option('hide-every-other')) {
				          if (hidLastImage) {
				            d_completeDisplay(fetchHistory(1), true, onload);
				            hidLastImage = false;
				          }
				          else {
				            d_displayBlank(onload);
				            hidLastImage = true;
				          }
				        }
				      }
				    }
				  }
				}
				
				// Display a random image.
				function d_displayRandom(onload) {
				  if (pointer === 0) {
				    let img = uploadF[exclusiveRandomIndex()];
				    d_completeDisplay(img, true, onload);
				    print('d_displayRandom() active');
				  }
				  else {
				    print('d_displayRandom() inactive');
				  }
				}
				
				// Random number generator.
				function exclusiveRandomIndex() {
				  if (option('prevent-recent-repeats')) {
				    let i,
				      unique = true,
				      memory = 20,
			        length = uploadF.length;
				    if (length <= memory) {
				      memory = length - 1;
				    }
				    memory = history.slice(0, memory);
				    // Keep going until nothing in memory matches.
				    while(true) {
				      i = randomIndex();
				      unique = true;
				      for (let prev of memory) {
				        if (prev === uploadF[i]) {
				          unique = false;
				          break;
				        }
				      }
				      if (unique) {
				        return i;
				      }
				    }
				  }
				  else {
				    return randomIndex();
				  }
				}
				
				function randomIndex() {
					return random(0, uploadF.length);
				}
				
				function random(min, max) { // Don't use negative numbers.
			    return Math.floor((Math.random() * max) + min);
			  }
				
				// Display the void.
				function d_displayBlank(onload) {
				  d_completeDisplay('', true, onload);
				  print('d_displayBlank()');
				}
				
				// Display the next image in file order.
				{
					// Have to keep track of this separately.
					let fileIndex = 0;
					function d_displayFileOrder(onload) {
						d_completeDisplay(uploadF[fileIndex], true, onload);
						fileIndex += 1;
						print('d_displayFileOrder()');
					}
					
					function d_setFileIndex(n) {
						fileIndex = n;
					}
				}
				
				// Display the next image in history.
				function d_displayNextHistory(onload) {
				  if (pointer > 0) {
				    pointer -= 1;
				    d_completeDisplay(fetchHistory(pointer), false, onload);
				    print('d_displayNextHistory() active');
				  }
				  else {
				    print('d_displayNextHistory() inactive');
				  }
				}
				
				// Display the previous image in history.
				$('previous').onclick = d_previous; function d_previous(onload) {
				  if (pointer >= 0 && pointer < (history.length - 1)) {
				    pointer += 1;
				    d_completeDisplay(fetchHistory(pointer), false, onload);
				    print('d_previous() active');
				  }
					else {
						print('d_previous() inactive');
					}
				}
			
			
			// Navigation buttons for edit-tags. Constrained to fileorder.
			$('tags-next').onclick = ()=>{
			  d_syncImageTags(()=>{
			    // Display the next image. (In fileorder, so no repeats)
			    d_next(false, false, 'tags-next');
			    d_listTags();
			  });
			}
			
			// Previous is always the same.
			$('tags-previous').onclick = ()=>{
			  d_syncImageTags(()=>{
			    d_previous();
			    if (pointer >= 0 && pointer < (history.length)) {
			      d_listTags();
			    }
			  });
			}
			
			// Update current image's tags based on the menu.
			function d_syncImageTags(wait) { // wait is probably stupid but idk
			  let tags = $('edit-tag-search').value // Get the textbox's value
			                  .trim() // Remove whitespace on outside of string
			                  .split(' '), // Convert to array
			      currentImagePath = fetchHistory(pointer).webkitRelativePath;
			  d_setConfig(currentImagePath, tags);
			  d_unsavedData('download-tags', true);
			  print('d_syncImageTags(): ' + currentImagePath);
			  print(tags);
			  if (typeof(wait) === 'function') {
			    wait();
			  }
			}
			
			// List current image's tags.
			function d_listTags() {
			  let current = fetchHistory(pointer),
			      path = current.webkitRelativePath,
			      tags = config('images')[path];
			  // Clear the last image's tags.
			  $('edit-tag-search').value = '';
			  // Update text box.
			  if (tags !== undefined) {
			    tags.forEach((tag)=>{
			      $('edit-tag-search').value += (tag + ' ');
			    });
			  }
			}
			
			// Let the user know when they have unsaved data.
			function d_unsavedData(downloadLink, has) {
			  if (has) {
			    $(downloadLink).innerHTML = 'Save settings (unsaved data)';
			  }
			  else {
			    $(downloadLink).innerHTML = 'Save settings';
			  }
			}
			
			// Image tagging. --------------------------------------------------------
			
			// display current image's tags
				// just below the name, but put a limit (based on char length, not tags)
				
			// Extend tags-list
		    // different link colors for custom tags
		    // valid search words arr
				
			// Config file sets default options and filter, title change + href
			
			// filename + tags + nonconforming-images-left have explanation text on hover
			
			// filter tags
			
			// Implement tags
			  // Tag descriptions with "ivconfig!-descr" entry in JSON
			  // normal tag: |red|
			    // "ivconfig!-color
			  // category tag: |color:red|
			    // but can have multiple of one category
			    // "ivconfig!-children" true/false determines if you have to include next layer, and how many if so
			      // This doesn't apply when you're just filtering
			  // mandatory tag: category tag that must be included
			  // recommended tag: everything that's not mandatory
			  // dependent tags:
			    // are actually just non-man cat tags
			    // click on tag color
			    // expands to color:red, color:blue, color:green, etc.
			    // tags list should have option to expand dependent tags
			
			// Jump to file, both modes (probably different impl.)
			  // Put it next to prev/next, but smaller font | Jump...
			
			// gohere
			// Edit tags box
		    // Add a tag filter here too
		    
			  // Remember extinct files, allow user to transfer tags from
			  
			  // User needs to be able to add tags of their own
		  
        // Display fewest tags, but not at the same time for fuck's sake?	
			  // Display un-man-tagged images first option
			  // Make a list of man tags on configInit
			    // Count num images w/o man tags -> fill text
			      // Inc/dec num w/o man tags
			      // Message on startup if images w/o man tags
				  
			// Hide the main menu when edit-tags is opened.
			$('open-edit-tags').addEventListener('click', ()=>{
		    d_setVisible($('box'), false);
		    // Sort//adasdasd
		    uploadF = sortUploadsFromMenu('tags-file-property', 'tags-file-order');
		    print('tags-file-sort()');
		    print(uploadF);
		    // Display current image's tags.
		    d_listTags();
			});
			// Show the main menu again when edit-tags is closed.
			$('close-edit-tags').addEventListener('click', ()=>{
			  d_setVisible($('box'), true);
			});
			
			// Hide and show tags based on user search.
			function hideTags (tagBox, tagList) {
			  let lamb = {};
			  lamb.tagsHidden = [];
			  lamb.fun = ()=>{
			    print('searchWord(): ' + searchWord(tagBox));
					// Re-show old tags
					lamb.tagsHidden.forEach((tag)=>{
						d_setVisible(tag, 'inline');
					});
					// Hide new tags
					lamb.tagsHidden = sortTags(searchWord(tagBox), tagBox, tagList);
					lamb.tagsHidden.forEach((tag)=>{
						d_setVisible(tag, false);
					});
			  };
			  return lamb.fun;
			}
			$('tag-search').oninput = hideTags('tag-search', 'tags-list');
			$('edit-tag-search').oninput = hideTags('edit-tag-search', 'edit-tags-list');
			
			// Make a list of tags that don't match the current search text.
			function sortTags(searchText, tagBox, tagList) {
				let search = $(tagBox),
						tagsContainer = $(tagList),
						tags = Array.prototype.slice.call(tagsContainer.childNodes),
						toHide = [];
				// Hide any tags that don't match the query so far.
				tags.forEach((tag)=>{ // can use array.filter for this
					let tagLink = tag.firstChild,
							tagName = tagLink.innerHTML || tagLink.innerText;
					// Test for not-matches.
					if (searchText.toUpperCase() !== tagName.slice(0, searchText.length).toUpperCase()) {
						toHide.push(tag);
					}
				});
				return toHide;
			}
			
			// Get the current search text.
			function searchWord(tagBox) {
				return $(tagBox).value
				.replace(/^\s/, '') // Remove any leading spaces.
				.split(' ').slice(-1)[0]; // Get the last word in the search.
			}
			
			// Sync the tag links with the current config file.
			function d_syncTagLinks(tagList, destination, exclude) {
			  let list = $(tagList);
			  // Clear children.
			  list.innerHTML = '';
			  // Add tags from config.
			  genTagLinks(destination, exclude).forEach((li)=>{
			    if (li) {
			      list.appendChild(li);
			    }
			  });
			}
			
			function genTagLinks(destination, exclude) {
			  let links = [];
			  config('tags-list').forEach((tag)=>{
			    links.push(genTagLink(tag, destination, exclude));
			  });
			  return links;
			}
			
			function genTagLink(tag, destination, exclude) {
			  // Only proceed if the tag is not a category tag.
			  if (tag.name.slice(-1) !== ':') {
			    let li = document.createElement('li'),
			        mainLink = document.createElement('a'),
			        excludeLink = document.createElement('a'),
			        content = tag.name;
			    // Set up links.
			    mainLink.href='#/';
			    mainLink.innerHTML = content;
			    // Hover text.
			    mainLink.title = tag.description;
			    mainLink.onclick = addTag(content, destination);
			    li.appendChild(mainLink);
			    if (exclude) {
			      excludeLink.href='#/';
			      excludeLink.innerHTML = '[!]';
			      excludeLink.onclick = addTag('!' + content, destination, '!');
			      li.appendChild(excludeLink);
			    }
			    // Keep the links from clustering together.
			    li.style.paddingRight = '5px';
			    return li;//<here>
			  }
			}
			
			function addTag(value, destination, prefix) { // ):
			  return (el)=>{
					let curr = $(destination).value,
							startIndex = curr.length - searchWord(destination).length;
					$(destination).value = curr.slice(0, startIndex) + // Remove word fragments.
						value + ' '; // Add a space to keep tags separate.
			  }
			}
			
			// Config files. ---------------------------------------------------------
			//
			$('download-tags').onclick = ()=>{
			  // Update tags.
			  d_syncImageTags();
			  // Download the new config.
			  downloadConfig();
			  d_unsavedData('download-tags', false);
			  print(config());
			}
			
			// Update config file settings from menu.
			{
			  let settings = $c('folder-setting');
			  $('download-folder').onclick = ()=>{
			    // Update config's settings.
			    settings.forEach((el)=>{
			      d_setConfig(el.id, el.value);
			    });
			    // Download the new config.
			    downloadConfig();
			    print(config());
			  }
			  
			  // Set the menu's settings to the current settings.
			  function d_syncEditFolder() {
			    settings.forEach((el)=>{
			      el.value = config(el.id);
			    });
			  }
			}
			
			// Read config file contents.
			function d_readConfig(file, onload) {
			  let reader = new FileReader();
			  reader.onload = (e)=>{
			    d_setConfig('', JSON.parse(e.target.result));
			    
			    if (typeof(onload) === 'function') {
			      onload();
			    }
			  }
			  reader.readAsText(file);
			}
			
			/*function readText(file) {
			  let reader = new FileReader();
			  reader.onload = (e)=>{
			    console.log(e.target.result);
			  }
        reader.readAsText(file);
			}*/
			
			// Make a text file from ivconfig.
			function downloadConfig() {
			  downloadText('ivconfig.txt', JSON.stringify(config()));
			}
			
			function downloadText(filename, text) {
			  // Set hidden link to download file on click.
        var link = $('download-link');
        link.setAttribute('href',
          'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        link.setAttribute('download', filename);
        // Prompt download.
        link.click();
      }
			
			// Config object.
			{
			  let ivconfig = {
			    'name': '',
			    'cover-image': '',
			    'tags-list': [], // holds descriptions and colors and such
			    'images': {},
			  };
			  /*
			  // Generate an array of every tag used.x
			  function generateTagsList() {
			    let acc = [],
			        tags = config('tags');
			    
			    return tags;
			  }*/
			  
			  function config(str) {
			    // Get the whole obj.
			    if (str === undefined || str === '') {
			      return ivconfig;
			    }
			    // Accessing an image's tags.
			    else if (isPath(str)) {
			      return ivconfig['images'][str];
			    }
			    // Accessing a property of the folder.
			    else {
			      return ivconfig[str];
			    }
			  }
			  
			  function d_setConfig(str, value) {
			    if (str === '') {
			      ivconfig = value;
			    }
			    else if (isPath(str)) {
			      ivconfig['images'][str] = value;
			    } 
			    else {
			      ivconfig[str] = value;
			    }
			    return ivconfig;
			  }
			}
			
			function isPath(str) {
			  if (str.split('/').length > 1) {
			    return true;
			  }
			  else {
			    return false;
			  }
			}
			
			// Keyboard shortcuts. ---------------------------------------------------
			{
				let active = true;
				    KEY_NEXT = 'ArrowRight',
						KEY_PREV = 'ArrowLeft';
						
				document.onkeydown = (e)=>{
					if (active) {
						e = e || window.event;
						if (e.key === KEY_NEXT) {
							$('next').click();
						}
						else if (e.key === KEY_PREV) {
							$('previous').click();
						}
					}
					else {
					}
				};
				
				function useKeys (t) {
					return active = t;
				}
				
				function listKeys () {
					s_print('next: ' + KEY_NEXT);
					s_print('prev: ' + KEY_PREV);
				}
			}
			
			// Disable shortcuts when focus is inside a text input.
			{
			  // All the inputs have nocancel
				let inputs = $c('cancel-key'); 
				inputs.listen('focus', ()=>{
				  useKeys(false);
				});
				inputs.listen('blur', ()=>{
				  useKeys(true);
				});
			}
			
			// Run the following on <startup>: ---------------------------------------
			window.onload = ()=>{
			  printTest(true);
			  
			  // In case they're reloading the page.
			  d_uploadInit();
			}
			
			// -----------------------------------------------------------------------
			
			
			
			// End -------------------------------------------------------------------
			
			// TODO
			// ivconfig.txt + Image tags
			// Get rid of the dotted outlines on click
			// Hide display option || keyboard shortcut as well
			// Pause timer when skipping/jumping w/e
			// POST (and ask about flashlights)
			// God what a pain in the ass. Learn this:
			  // https://medium.com/quick-code/javascript-promises-in-twenty-minutes-3aac5b65b887
			// Image comments
		</script>
  </body>
</html>
