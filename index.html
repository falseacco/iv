<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>image viewer</title>
  </head>
  <body>
		<style>
      .smaller {
				font-size: small;
			}		
		
		  .monospace {
				font-family: monospace;
			}
			
			.indent1 {
				margin-left: 10px;
			}
			.indent2 {
				margin-left: 25px;
			}
			.indent3 {
			  margin-left: 35px;
			}
		
			a:visited {
				color: #0000EE;
			}
			a:hover {
			  color: #551A8B;
			}
			a:active {
				color: #551A8B;
			}
			
			.black-link {
			  color: black;
			}
			.black-link:visited {
			  color: black;
			}
			.black-link:hover {
			  color: #551A8B;
			}
			.black-link:active {
			  color: #551A8B;
			}
			
			.gray-link {
			  color: gray;
			}
			.gray-link:visited {
			  color: gray;
			}
			.gray-link:hover {
			  color: #551A8B;
			}
			.gray-link:active {
			  color: #551A8B;
			}
			
			[draggable=true] {
				cursor: move;
			}
		
			#bg { /* Workaround to prevent fullscreen from changing page color. */
				/* Color. */
				background-color: white;
				/* All the way in the back. */
				position: absolute;
				z-index: -9001;
				/* Take up the whole page. */
				top: 0;
				left: 0;
				height: 100%;
				width: 100%;
			}
		  /* Workaround to allow text inputs in draggable divs to be selected. */
			.nocancel {
			}
			
			#title {
				/* Keep it from having infinite width. */
				display: inline-block;
				/* Stay away from the sides in fullscreen. */
				margin-left: 20px;
			}
			#title h1 {
				/* This can't move, so it should be covered by the image if necessary.
				If the main link had this it wouldn't be clickable. */
				position: relative;
		    z-index: -2;
				/* Positioning */
				margin: 40px 0 20px 0;
		  }
			
			.box {
				position: absolute; /* Draggy. */
				/* Appearance */
				border: 1px solid lightgray;
				display: inline-block;
				padding: 0 5px 5px 5px;
			}
			#ghost {
				display: none;
			}
			
			#filename {
			  background-color: white;
			  font-size: 12px;
			}
			
			#reset {
			  margin-left: 60px;
			  background-color: white;
			}
			
			#timer {
				/* Make it stand out a bit. */
				margin-left: 5px;
				font-size: 22px;
				background-color: white;
			}
			
			#display {
				/* Don't cover up anything else, except the title sometimes. */
				position: absolute;
				z-index: -1;
				background-color: transparent;
				/* Take up the whole page. */
				top: 0;
				left: 0;
				height: 100%;
				width: 100%;
				background-size: auto 100%;
				/* Center the background image. */
				background-position: center;
				/* Don't use the image as a tile. */
				background-repeat: no-repeat;
			}
			
			#hide-section-options {
			  display: none;
			}
			
			#download-link {
			  display: none;
			}
		</style>
		<div id="bg"></div>
		
		<div id="display"></div>
		
		<a id="title" class="black-link" href="https://www.github.com/ooorel/iv"
		   target="_blank" rel="noopener noreferrer">
		  <h1>iv</h1>
		</a><br>
		
		<div id="box" class="box" draggable="true">
			<a id="hide" class="smaller link" href="#/">[hide]</a><br>
			<span id="hide-section-top">
			<br>
				<input id="upload" type="file" webkitdirectory directory multiple><br>
				<a id="fullscreen" class="link" href="#/">toggle fullscreen</a><br>
				<br>
			</span>
			<text id="filename"></text><br>
			<a id="previous" class="link" href="#/" inactive>previous</a>
			<a id="next" class="link" href="#/">next</a><br>
			<br>
			<a id="reset" class="gray-link" href="#/">&#8635;</a>
			<a id="timer" class="gray-link" href="#/">10:00</a><br>
			<span id="hide-section-timer">
			<br >
				<text>Options</text>
				<a id="hide-options" class="smaller" href="#/">[show]</a>
				<text>:</text>
				<br>
				<span id="hide-section-options">
				  <text class="indent1">Length:</text><br>
					  <input id="timer-hr" type="text" class="nocancel indent2 monospace"
					  placeholder="00" size="2" maxlength="2" autocomplete="off"> :
					  <input id="timer-min" type="text" class="nocancel monospace"
					  placeholder="10" size="2" maxlength="2" autocomplete="off"> :
					  <input id="timer-sec" type="text" class="nocancel monospace"
					  placeholder="00" size="2" maxlength="2" autocomplete="off"><br>
				  <input id="prevent-recent-repeats" type="checkbox"
				  class="indent1" checked>Prevent recent repeats<br> 
				  <input id="hide-every-other" type="checkbox"
				  class="indent1">Hide every other image<br>    
					<input id="display-new" type="checkbox"
					class="indent1" checked>Display new images on skip<br>
				  <text class="indent1">When timer ends:</text><br>
				    <input id="on-end-display-new" type="checkbox"
				    class="indent2" checked>display new image<br>
					  <input id="on-end-reset" type="checkbox"
					  class="indent2" checked>reset time &#8635;<br>
					    <input id="on-end-count" type="checkbox"
					    class="indent3" checked>start counting down<br>
				</span>
			</span>
		</div>
		<div id="ghost" class="box"></div>
		
		<a id="download-link"></a>
			
		<script type="text/javascript">
			"use strict;"
			{
			  let testing = true;
			  
			  function print(x) {
			    if (testing) {
			      console.log(x);
			    }
			  }
			  
				function s_print(x) { // strong print
					console.log(x);
				}
			  
			  function printTest(t) {
			    testing = t;
			    s_print('Printing tests: ' + t);
			  }
			}
			
			function $(x) {
				if (typeof(x) == 'string') {
					return document.getElementById(x);
				}
				return x;
			}
			
			function random(min, max) { // Don't use negative numbers.
			  return Math.floor((Math.random() * max) + min);
			}
			
			// Hiding things.
			$('hide').onclick = ()=>{
				// Toggle content.
				let visible = d_toggleDisplay('hide-section-top');
				d_setVisible('hide-section-timer', visible);
				// Update label.
				if (visible) {
					$('hide').innerHTML = '[hide]';
				}
				else {
					$('hide').innerHTML = '[show]';
				}
			}
			
			$('hide-options').onclick = ()=>{
				// Toggle content.
				let visible = d_toggleDisplay('hide-section-options');
				// Update label.
				if (visible) {
					$('hide-options').innerHTML = '[hide]';
				}
				else {
					$('hide-options').innerHTML = '[show]';
				}
			}
			
			function d_toggleDisplay(id) {
				let mode = window.getComputedStyle($(id)).display;
				if (mode === 'none') {
					return d_setVisible(id, true);
				}
				else {
					return d_setVisible(id, false);
				}
			}
			
			function d_setVisible(id, value) {
				$(id).style.display = value ? 'block' : 'none';
				return value;
			}
			
			// Draggable divs | refactored copy-paste --------------------------------
			d_draggable('box');
			function d_draggable(id) {
				let posx,
						posy,
						xOffset,
						yOffset,
						el = $(id),
						ghost = $('ghost');
						
				el.addEventListener('mousedown', click);
				
				function click(e) {
					e = e || window.event;
					if (!e.explicitOriginalTarget.classList ||
							e.explicitOriginalTarget.classList[0] !== 'nocancel') {
						e.preventDefault();
					}
					if (e.target.id !== id) {
						return false;
					}
					// Get initial mouse position.
					posx = e.clientX;
					posy = e.clientY;
					// Get offset from top left corner.
					let rect = el.getBoundingClientRect();
					xOffset = posx - rect.x;
					yOffset = posy - rect.y;
					// Set ghost size.
					ghost.style.paddingRight = rect.width + 'px';
					ghost.style.height = rect.height + 'px';
					// Show the ghost.
					d_setVisible('ghost', true);
					// And hide the box.
					d_setVisible(id, false);
					// Don't want to be running this code all the time.
					document.onmouseup = close;
					document.onmousemove = drag;
					
					print('clicked box');
				}
				
				function drag(e) {
					e = e || window.event;
					e.preventDefault();
					// Update mouse position.
					posx = e.clientX;
					posy = e.clientY;
					// Move the ghost preview.
					ghost.style.left = (posx - xOffset) + 'px';
					ghost.style.top = (posy - yOffset) + 'px';
					
					print('dragging box');
				}
				
				function close() {
					// Hide the ghost.
					d_setVisible('ghost', false);
					// Show the box.
					d_setVisible(id, true);
					// Set the element's new position.
					el.style.left = (posx - xOffset) + 'px';
					el.style.top = (posy - yOffset) + 'px';
					// Stop doing things when the mouse is released.
					document.onmouseup = null;
					document.onmousemove = null;
					
					print('let go of box');
				}
			}
			
			// Fullscreen | copy-paste -----------------------------------------------
			function requestFullscreen(el) {
				if(el.requestFullscreen)
					el.requestFullscreen();
				else if(el.mozRequestFullScreen)
					el.mozRequestFullScreen();
				else if(el.webkitRequestFullscreen)
					el.webkitRequestFullscreen();
				else if(el.msRequestFullscreen)
					el.msRequestFullscreen();
			}
			
			function exitFullscreen() {
				if(document.exitFullscreen)
					document.exitFullscreen();
				else if(document.mozCancelFullScreen)
					document.mozCancelFullScreen();
				else if(document.webkitExitFullscreen)
					document.webkitExitFullscreen();
				else if(document.msExitFullscreen)
					document.msExitFullscreen();
			}
			
			function isFullscreen() {
				var full_screen_element = document.fullscreenElement ||
				    document.webkitFullscreenElement ||
				    document.mozFullScreenElement ||
				    document.msFullscreenElement ||
				    null;
	
				// If no element is in full-screen
				if (full_screen_element === null) {
					return false;
				}
				else {
					return true;
				}
			}
			
			// Fullscreen has to be triggered by a click, idk
			$('fullscreen').onclick = ()=>{
				if (isFullscreen()) {
					exitFullscreen();
				}
				else {
					requestFullscreen(document.body);
				}
			}
			
			// Timer. ----------------------------------------------------------------
			{
			  let counting = false,
			      hidLastImage = false,
			      i;
			  
			  $('reset').onclick = d_reset;
			  
			  $('timer').onclick = ()=>{
			    if (!counting) {
			      d_resume();
			    }
			    else {
			      d_pause();
			    }
			  }
			  
			  function d_resume(){
			    // Timer is counting.
		      d_startCount('resume');
		      counting = true;
		      // Change colors to something hard to miss.
		      $('timer').className = 'black-link';
		      $('reset').className = '';
			  }
			  
			  function d_pause(){
			    // Timer is just there.
	        d_endCount('pause');
	        counting = false;
	        // Change colors to something easy to ignore.
	        $('timer').className = 'gray-link';
	        $('reset').className = 'gray-link';
			  }
			  
			  function d_reset() {
			    d_pause();
			    d_displayTimer(arrToStr(option('timer-length')));
			  }
			  
			  // count
			  function d_endCount(from) { // reset pause
			    // Stop counting.
			    clearInterval(i);
			    if (from === 'reset') {
			      if (option('on-end-reset')) {
			        // Reset timer.
			        d_displayTimer(arrToStr(option('timer-length')));
			        // Start counting down.
			        if (option('on-end-count')) {
			          // Display a new image, but don't start counting until it loads.
			          if (option('on-end-display-new')) {
			            d_next('', ()=>{
			              d_startCount('reset');
			              },
			              'reset');
			          }
			          // Count down without changing the display.
			          else {
			            print('else');
			            d_startCount('reset');
			          }
			        }
			      }
			      else {
			        // Just display a new image.
			        d_next();
			      }
			    }
			  }
			  
			  function d_startCount(from) {
			    let goal;
			    if (from === 'reset') {
			      goal = getGoal(option('timer-length'));
			    }
			    else {
			      goal = getGoal(strToArr(currentTimer()));
			    }
			    d_count(goal);
			  }
			  
			  function d_count(goal) {
			    // Stop previous countdown.
			    clearInterval(i);
			    // Set function to decrement.
			    i = setInterval(()=>{
			      let remaining = goal - Date.now(),
			          arr = msToArr(remaining),
			          str = arrToStr(arr);
			      d_displayTimer(str);
			      // When the timer reaches zero:
			      if (remaining <= 500) {
			        d_endCount('reset');
			        print('end timer');
			      }
			    }, 225);
			  }
			  
			  function getGoal(arr) {
			    return Date.now() + arrToMs(arr);
			  }
			  
			  // Update timer's display.
			  function d_displayTimer(str) {
			    $('timer').innerHTML = str;
			  }
			  
			  function currentTimer() {
			    return $('timer').innerHTML;
			  }
			  
			  // Convert a time array to a string for display, and vice versa.
			  function strToArr(str) {
			    let arr = str.split(':');
			    if (arr.length < 3) {
			      arr.unshift('00');
			    }
			    return arr;
			  }
			  
			  function arrToStr(arr) {
			    let str = padNum(arr[0]) + ':' + 
			              padNum(arr[1]) + ':' + 
			              padNum(arr[2]);
			    if (str.slice(0, 2) === '00') {
			      str = str.slice(3);
			    }
			    else if (str[0] === '0') {
			      str = str.slice(1);
			    }
			    return str;
			  }
			  
			  // Convert a time array to milliseconds and vice versa.
			  function msToArr(ms) {
			    let sec = Math.floor(ms / 1000),
			        hr,
			        min;
			    hr = Math.floor(sec / 3600);
			    sec -= hr * 3600;
			    min = Math.floor(sec / 60);
			    sec -= min * 60;
			    return [padNum(hr), padNum(min), padNum(sec)];
			  }
			  
			  function padNum(n) {
			    n = Number(n);
			    if (n < 10) {
			      return '0' + n;
			    }
			    else {
			      return '' + n;
			    }
			  }
			  
			  function arrToMs(arr) {
			    return (arr[0] * 60 * 60 * 1000) +
			           (arr[1] * 60 * 1000) +
			           (arr[2] * 1000);
			  }
			  
			  // Fetch settings from Options.
			  function option(id) {
			    if (id === 'timer-length') {
			      return timerLength();
			    }
			    else {
			      return $(id).checked;
			    }
			  }
			  
			  function timerLength() {
			    let hr = $('timer-hr').value || '00',
			        min = $('timer-min').value || '10',
			        sec = $('timer-sec').value || '00',
			        length = [hr, min, sec];
			    return length;
			  }
			}
			
			// File upload and navigation. -------------------------------------------
			{
				let upload = [],  // Images user uploads.
				    uploadP = {}, // path: Images in upload with filepath as id.
				    uploadF = [], // filter: This is the collection to sort.
				    history = [], // Record of files user's viewed this session.
						pointer = 0,  // Place in history. 0 is most recent, 1 is 2nd-most.
						hidLastImage = false; // For memory drawing.
			
			  function fetchHistory(pointer) {
			    return history[pointer];
			  }
			
			  function d_archive(file) {
			    history.unshift(file);
			    return file;
			  }
			  
			  // Display an image, update the ui, and archive it for later.
			  function d_completeDisplay(img, doArchive, onload) {
			    d_display(img, onload);
			    d_displayFilename(img);
			    if (doArchive) {
			      d_archive(img);
			    }
			  }
			  
			  // Display an image.
			  function d_display (img, onload) {
			    if (img === '' || img === undefined) { // Clear the display.
			      $('display').style.backgroundImage = '';
			      // Delay tasks.
			      if (typeof(onload) === 'function') {
					      onload();
					  }
			    }
			    else { // Draw the image.
			      let reader = new FileReader();
				    reader.readAsDataURL(img);
				    reader.onload = (e)=>{
					    let url = e.target.result;
					    $('display').style.backgroundImage = 'url(' + url + ')';

					    if (typeof(onload) === 'function') {
					      onload();
					    }
				    };
			    }
			  }
			  
			  function d_displayFilename(img) {
				  let name;
				  if (img === '' || img === undefined) {
				    name = '...';
				  }
				  else {
				    name = img.webkitRelativePath;
				    if (name.length > 31) {
				      name = name.slice(0, 25) + '...' + name.slice(-3);
				    }
				  }
				  $('filename').innerHTML = name;
				}
			
				$('upload').onchange = d_uploadInit; function d_uploadInit(e) {
					upload = Array.from($('upload').files);
					// Make sure there's some data before working.
					if (upload.length > 0) {
					  // Filter out any non-image files.
					  upload.forEach((file, i)=>{
					    let name = file.name;
					    // File isn't an image, remove it.
					    if (!isDisplay(filetype(name))) {
					      upload.splice(i, 1);
					      print('Removed file from display list: ' + name);
					      // File is a config, use it.
					      if (name === 'ivconfig.txt') {
					        print('Found config file!');
					        d_readConfig(file, ()=>{
					          print('callback');
					          // There might not have been any images in the upload.
					          if (upload.length > 0) {
					            // Display an image to start.
					            let cover = config('cover-img'),
					                        img;
					            // No cover image specified.
					            if (cover === undefined) {
					              img = upload[0];
					            }
					            // Cover image is provided as a path.
					            else if (isPath(cover)) {
					              img = uploadF[cover];
					            }
					            // Cover image is provided as an index.
					            else {
					              img = upload[Number(cover)];
					            }
					            d_completeDisplay(img, true);
					          }
					        });
					      }
					    }
					    // File is an image, store it in a hash for name lookup.
					    else {
					      let path = file.webkitRelativePath;
					      uploadF[path] = file;
					    }
					  });
					}
					print('d_uploadInit()');
					print(upload);
				}
				
				// Check if a file is good to display.
				{
				  let valid = ['jpg'.toLocaleUpperCase(),
				               'png'.toLocaleUpperCase(),
				               'jpeg'.toLocaleUpperCase()];
				  function isDisplay(extension) {
				    extension = extension.toLocaleUpperCase();
				    for (i in valid) {
				      let type = valid[i];
				      if (extension === type) {
				        return true;
				      }
				    }
				    return false;
				  }
				}
				
				// Get a file's extension.
				function filetype(name) {
				  return name.split('.').slice(-1)[0];
				}
				
				$('next').onclick = d_next; function d_next(e, onload, from) {
				  if (upload.length !== 0) {
				    if (pointer > 0) {
				      d_displayNextHistory(onload);
				    }
				    else {
				      if (option('display-new') ||
				          from === 'reset' && option('on-end-display-new')) {
				        if (option('hide-every-other')) {
				          if (hidLastImage) {
				            d_displayRandom(onload);
				            hidLastImage = false;
				          }
				          else {
				            d_displayBlank(onload);
				            hidLastImage = true;
				          }
				        }
				        else {
				          d_displayRandom(onload);
				        }
				      }
				      else {
				        if (option('hide-every-other')) {
				          if (hidLastImage) {
				            d_completeDisplay(fetchHistory(1), true, onload);
				            hidLastImage = false;
				          }
				          else {
				            d_displayBlank(onload);
				            hidLastImage = true;
				          }
				        }
				      }
				    }
				  }
				}
				
				// Display a random image.
				function d_displayRandom(onload) {
				  if (pointer === 0) {
				    let img = upload[exclusiveRandomIndex()];
				    d_completeDisplay(img, true, onload);
				    print('d_displayRandom() active');
				  }
				  else {
				    print('d_displayRandom() inactive');
				  }
				}
				
				// Random number generator.
				function exclusiveRandomIndex() {
				  if (option('prevent-recent-repeats')) {
				    let i,
				      unique = true,
				      memory = 20,
			        length = upload.length;
				    if (length <= memory) {
				      memory = Math.floor(length / 2);
				    }
				    memory = history.slice(0, memory);
				    // Keep going until nothing in memory matches.
				    while(true) {
				      i = randomIndex();
				      unique = true;
				      for (let prev of memory) {
				        if (prev === i) {
				          unique = false;
				          break;
				        }
				      }
				      if (unique) {
				        return i;
				      }
				    }
				  }
				  else {
				    return randomIndex();
				  }
				}
				
				function randomIndex() {
					return random(0, upload.length);
				}
				
				// Display the void.
				function d_displayBlank(onload) {
				  d_completeDisplay('', true, onload);
				  print('d_displayBlank');
				}
				
				// Display the next image in history.
				function d_displayNextHistory(onload) {
				  if (pointer > 0) {
				    pointer -= 1;
				    d_completeDisplay(fetchHistory(pointer), false, onload);
				    print('d_displayNextHistory() active');
				  }
				  else {
				    print('d_displayNextHistory() inactive');
				  }
				}
				
				// Display the previous image in history.
				$('previous').onclick = d_previous; function d_previous(onload) {
				  if (pointer >= 0 && pointer < (history.length - 1)) {
				    pointer += 1;
				    d_completeDisplay(fetchHistory(pointer), false, onload);
				    print('d_previous() active');
				  }
					else {
						print('d_previous() inactive');
					}
				}
			}
			
			// Folder config files and image tagging. --------------------------------
			// go here
			
			// Config file sets default options and filter, title change
			
			// Jump to file, both modes (probably different impl.)
			
			// nond Filter tags, return arr
			
			// Folder tag editor
			
			// Implement tags
			  // Tag descriptions with "ivconfig!-descr" entry in JSON
			  // normal tag: |red|
			  // category tag: |color:red|
			    // but can have multiple of one category
			    // "ivconfig!-children" true/false determines if you have to include next layer, and how many if so
			      // This doesn't apply when you're just filtering
			  // mandatory tag: category tag that must be included
			  // recommended tag: everything that's not mandatory
			  // dependent tags:
			    // are actually just non-man cat tags
			    // click on tag color
			    // expands to color:red, color:blue, color:green, etc.
			
			// Folder tag filter (hidden until upload), edit tags link opens to closeable box
			  // Move toggle fullscreen to top
			  // Put filter there
			
			// Read config file contents.
			function d_readConfig(file, onload) {
			  let reader = new FileReader();
			  reader.onload = (e)=>{
			    d_setConfig('', JSON.parse(e.target.result));
			    
			    if (typeof(onload) === 'function') {
			      onload();
			    }
			  }
			  reader.readAsText(file);
			}
			
			/*function readText(file) {
			  let reader = new FileReader();
			  reader.onload = (e)=>{
			    console.log(e.target.result);
			  }
        reader.readAsText(file);
			}*/
			
			// Make a text file from ivconfig.
			function downloadConfig() {
			  downloadText('ivconfig.txt', JSON.stringify(config()));
			}
			
			function downloadText(filename, text) {
			  // Set hidden link to download file on click.
        var link = $('download-link');
        link.setAttribute('href',
          'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        link.setAttribute('download', filename);
        // Prompt download.
        link.click();
      }
			
			// Config object.
			{
			  let ivconfig = {
			    'title': 'none',
			    'cover-img': 'none',
			    'tags': {}
			  };
			  
			  function config(str) {
			    // Get the whole obj.
			    if (str === undefined || str === '') {
			      return ivconfig;
			    }
			    // Accessing an image's tags.
			    else if (isPath(str)) {
			      return ivconfig['tags'][str];
			    }
			    // Accessing a property of the folder.
			    else {
			      return ivconfig[str];
			    }
			  }
			  
			  function d_setConfig(str, value) {
			    if (str === '') {
			      ivconfig = value;
			    }
			    else if (isPath(str)) {
			      ivconfig['tags'][str] = value;
			    } 
			    else {
			      ivconfig[str] = value;
			    }
			  }
			}
			
			function isPath(str) {
			  if (str.split('/').length > 1) {
			    return true;
			  }
			  else {
			    return false;
			  }
			}
			
			// Keyboard shortcuts. ---------------------------------------------------
			{
				let active = true;
				    KEY_NEXT = 'ArrowRight',
						KEY_PREV = 'ArrowLeft';
						
				document.onkeydown = (e)=>{
					if (active) {
						e = e || window.event;
						if (e.key === KEY_NEXT) {
							$('next').click();
						}
						else if (e.key === KEY_PREV) {
							$('previous').click();
						}
					}
					else {
					}
				};
				
				function useKeys (t) {
					return active = t;
				}
				
				function listKeys () {
					s_print('next: ' + KEY_NEXT);
					s_print('prev: ' + KEY_PREV);
				}
			}
			
			// Disable shortcuts when focus is inside a text input.
			{
				let inputs = ['timer-hr', 'timer-min', 'timer-sec'];
				inputs.forEach((id)=>{
					$(id).onfocus = ()=>{ // Why does addEventListener not work here?
						useKeys(false);
					}
					$(id).onblur = ()=>{
						useKeys(true);
					}
				});
			}
			
			// Run the following on <startup>: ---------------------------------------
			printTest(true);
			
			// In case they're reloading the page.
			$('upload').onchange();
			
			// -----------------------------------------------------------------------
			
			
			
			// End -------------------------------------------------------------------
			
			// TODO
			// ivconfig.txt + Image tags
			// File order sort
			// God what a pain in the ass. Learn this:
			  // https://medium.com/quick-code/javascript-promises-in-twenty-minutes-3aac5b65b887
		</script>
  </body>
</html>
