<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>image viewer</title>
  </head>
  <body>
		<style>
			a:visited {
				color: #0000EE;
			}
			a:hover {
			  color: #551A8B;
			}
			a:active {
				color: #551A8B;
			}
			
			.black-link {
			  color: black;
			}
			.black-link:visited {
			  color: black;
			}
			.black-link:hover {
			  color: #551A8B;
			}
			.black-link:active {
			  color: #551A8B;
			}
			
			.gray-link {
			  color: gray;
			}
			.gray-link:visited {
			  color: gray;
			}
			.gray-link:hover {
			  color: #551A8B;
			}
			.gray-link:active {
			  color: #551A8B;
			}
		
			.monospace {
				font-family: monospace;
			}
			
			.indent1 {
				margin-left: 10px;
			}
			.indent2 {
				margin-left: 25px;
			}
			.indent3 {
			  margin-left: 35px;
			}
			
			[draggable=true] {
				cursor: move;
			}
		
			#bg { /* Workaround to prevent fullscreen from changing page color. */
				/* Color. */
				background-color: white;
				/* All the way in the back. */
				position: absolute;
				z-index: -9001;
				/* Take up the whole page. */
				top: 0;
				left: 0;
				height: 100%;
				width: 100%;
			}
		  
			.nocancel { /* Workaround to allow text inputs within draggable divs to be selected. */
			}
			
			#title {
				/* Keep it from having infinite width. */
				display: inline-block;
				/* Stay away from the sides in fullscreen. */
				margin-left: 20px;
			}
			#title h1 {
				/* This can't move, so it should be covered by the image if necessary.
				If the main link had this it wouldn't be clickable. */
				position: relative;
		    z-index: -2;
				/* Positioning */
				margin: 40px 0 20px 0;
		  }
			
			.box {
				position: absolute; /* Draggy. */
				/* Appearance */
				border: 1px solid lightgray;
				display: inline-block;
				padding: 0 5px 5px 5px;
			}
			#ghost {
				display: none;
			}
			
			.smaller {
				font-size: small;
			}
			
			#reset {
			  margin-left: 60px;
			}
			
			#timer {
				/* Make it stand out a bit. */
				margin-left: 5px;
				font-size: 22px;
				background-color: white;
			}
			
			#display {
				/* Don't cover up anything else, except the title sometimes. */
				position: absolute;
				z-index: -1;
				background-color: transparent;
				/* Take up the whole page. */
				top: 0;
				left: 0;
				height: 100%;
				width: 100%;
				background-size: auto 100%;
				/* Center the background image. */
				background-position: center;
				/* Don't use the image as a tile. */
				background-repeat: no-repeat;
			}
			
			#hide-section-options {
			  display: none;
			}
		</style>
		<div id="bg"></div>
		
		<a id="title" class="black-link" href="https://www.github.com/ooorel/iv" target="_blank" rel="noopener noreferrer">
		  <h1>iv</h1>
		</a><br>
		
		<div id="box" class="box" draggable="true">
			<a id="hide" class="smaller link" href="#/">[hide]</a><br>
			<span id="hide-section-top">
			<br>
				<input id="upload" type="file" webkitdirectory directory multiple><br>
				<a id="fullscreen" class="link" href="#/">toggle fullscreen</a><br>
				<br>
			</span>
			<text id="filename"></text><br>
			<a id="previous" class="link" href="#/" inactive>previous</a>
			<a id="next" class="link" href="#/">next</a><br>
			<br>
			<a id="reset" class="gray-link" href="#/">&#8635;</a>
			<a id="timer" class="gray-link" href="#/">10:00</a><br>
			<span id="hide-section-timer">
			<br >
				<text>Options</text>
				<a id="hide-options" class="smaller" href="#/">[show]</a>
				<text>:</text>
				<br>
				<span id="hide-section-options">
				  <text class="indent1">Length:</text><br>
					  <input id="timer-hr" type="text" class="nocancel indent2 monospace" placeholder="00" size="2" maxlength="2" autocomplete="off"> :
					  <input id="timer-min" type="text" class="nocancel monospace" placeholder="10" size="2" maxlength="2" autocomplete="off"> :
					  <input id="timer-sec" type="text" class="nocancel monospace" placeholder="00" size="2" maxlength="2" autocomplete="off"><br>
				  <input id="hide-every-other" type="checkbox" class="indent1">Hide every other image<br>    
					<input id="display-new" type="checkbox" class="indent1" checked>Display new images<br>
				  <text class="indent1">When timer ends:</text><br>
				    <input id="on-end-display-new" type="checkbox" class="indent2" checked>display new image<br>
					  <input id="on-end-reset" type="checkbox" class="indent2" checked>reset &#8635;<br>
					    <input id="on-end-count" type="checkbox" class="indent3" checked>start counting down<br>
				</span>
			</span>
		</div>
		<div id="ghost" class="box"></div>
			
		<div id="display"></div>
			
			
		<script type="text/javascript">
			"use strict;"
			{
			  let testing = true;
			  
			  function print(x) {
			    if (testing) {
			      console.log(x);
			    }
			  }
			  
				function s_print(x) { // strong print
					console.log(x);
				}
			  
			  function printTest(t) {
			    testing = t;
			    s_print('printing tests: ' + t);
			  }
			}
			
			function $(x) {
				if (typeof x == 'string') {
					return document.getElementById(x);
				}
				return x;
			}
			
			function random(min, max) { // Don't use negative numbers.
			  return Math.floor((Math.random() * max) + min);
			}
			
			// Hiding things.
			$('hide').onclick = ()=>{
				// Toggle content.
				let visible = d_toggleDisplay('hide-section-top');
				d_setVisible('hide-section-timer', visible);
				// Update label.
				if (visible) {
					$('hide').innerHTML = '[hide]';
				}
				else {
					$('hide').innerHTML = '[show]';
				}
			}
			
			$('hide-options').onclick = ()=>{
				// Toggle content.
				let visible = d_toggleDisplay('hide-section-options');
				// Update label.
				if (visible) {
					$('hide-options').innerHTML = '[hide]';
				}
				else {
					$('hide-options').innerHTML = '[show]';
				}
			}
			
			function d_toggleDisplay(id) {
				let mode = window.getComputedStyle($(id)).display;
				if (mode === 'none') {
					return d_setVisible(id, true);
				}
				else {
					return d_setVisible(id, false);
				}
			}
			
			function d_setVisible(id, value) {
				$(id).style.display = value ? 'block' : 'none';
				return value;
			}
			
			// Timer.
			{
			  let counting = false,
			      hidLastImage = false,
			      i;
			  
			  $('reset').onclick = d_reset;
			  
			  $('timer').onclick = ()=>{
			    if (!counting) {
			      d_resume();
			    }
			    else {
			      d_pause();
			    }
			  }
			  
			  function d_resume(){
			    // Timer is counting.
		      d_startCount('resume');
		      counting = true;
		      // Change colors to something hard to miss.
		      $('timer').className = 'black-link';
		      $('reset').className = '';
			  }
			  
			  function d_pause(){
			    // Timer is just there.
	        d_endCount('pause');
	        counting = false;
	        // Change colors to something easy to ignore.
	        $('timer').className = 'gray-link';
	        $('reset').className = 'gray-link';
			  }
			  
			  function d_reset() {
			    d_pause();
			    d_displayTimer(arrToStr(option('timer-length')));
			  }
			  
			  // count
			  function d_endCount(from) { // reset pause
			    // Stop counting.
			    clearInterval(i);
			    if (from === 'reset') {
			      if (option('on-end-reset')) {
			        // Reset timer.
			        d_displayTimer(arrToStr(option('timer-length')));
			        // Start counting down.
			        if (option('on-end-count')) {
			          // Display a new image, but don't start counting until it loads.
			          if (option('on-end-display-new')) {
			            d_next('', ()=>{
			              d_startCount('reset');
			              },
			              'reset');
			          }
			          // Count down without changing the display.
			          else {
			            print('else');
			            d_startCount('reset');
			          }
			        }
			      }
			      else {
			        // Just display a new image.
			        d_next();
			      }
			    }
			  }
			  
			  function d_startCount(from) {
			    let goal;
			    if (from === 'reset') {
			      goal = getGoal(option('timer-length'));
			    }
			    else {
			      goal = getGoal(strToArr(currentTimer()));
			    }
			    d_count(goal);
			  }
			  
			  function d_count(goal) {
			    // Stop previous countdown.
			    clearInterval(i);
			    // Set function to decrement.
			    i = setInterval(()=>{
			      let remaining = goal - Date.now(),
			          arr = msToArr(remaining),
			          str = arrToStr(arr);
			      d_displayTimer(str);
			      // When the timer reaches zero:
			      if (remaining <= 500) {
			        d_endCount('reset');
			        print('end timer');
			      }
			    }, 225);
			  }
			  
			  function getGoal(arr) {
			    return Date.now() + arrToMs(arr);
			  }
			  
			  // Update timer's display.
			  function d_displayTimer(str) {
			    $('timer').innerHTML = str;
			  }
			  
			  function currentTimer() {
			    return $('timer').innerHTML;
			  }
			  
			  // Convert a time array to a string for display, and vice versa.
			  function strToArr(str) {
			    let arr = str.split(':');
			    if (arr.length < 3) {
			      arr.unshift('00');
			    }
			    return arr;
			  }
			  
			  function arrToStr(arr) {
			    let str = padNum(arr[0]) + ':' + 
			              padNum(arr[1]) + ':' + 
			              padNum(arr[2]);
			    if (str.slice(0, 2) === '00') {
			      str = str.slice(3);
			    }
			    else if (str[0] === '0') {
			      str = str.slice(1);
			    }
			    return str;
			  }
			  
			  // Convert a time array to milliseconds and vice versa.
			  function msToArr(ms) {
			    let sec = Math.floor(ms / 1000),
			        hr,
			        min;
			    hr = Math.floor(sec / 3600);
			    sec -= hr * 3600;
			    min = Math.floor(sec / 60);
			    sec -= min * 60;
			    return [padNum(hr), padNum(min), padNum(sec)];
			  }
			  
			  function padNum(n) {
			    n = Number(n);
			    if (n < 10) {
			      return '0' + n;
			    }
			    else {
			      return '' + n;
			    }
			  }
			  
			  function arrToMs(arr) {
			    return (arr[0] * 60 * 60 * 1000) +
			           (arr[1] * 60 * 1000) +
			           (arr[2] * 1000);
			  }
			  
			  // Fetch settings from Options.
			  function option(id) {
			    if (id === 'timer-length') {
			      return timerLength();
			    }
			    else {
			      return $(id).checked;
			    }
			  }
			  
			  function timerLength() {
			    let hr = $('timer-hr').value || '00',
			        min = $('timer-min').value || '10',
			        sec = $('timer-sec').value || '00',
			        length = [hr, min, sec];
			    return length;
			  }
			}
			
			// Draggable divs | refactored copy-paste
			d_draggable('box');
			function d_draggable(id) {
				let posx,
						posy,
						xOffset,
						yOffset,
						el = $(id),
						ghost = $('ghost');
						
				el.addEventListener('mousedown', click);
				
				function click(e) {
					e = e || window.event;
					if (!e.explicitOriginalTarget.classList ||
							e.explicitOriginalTarget.classList[0] !== 'nocancel') {
						e.preventDefault();
					}
					if (e.target.id !== id) {
						return false;
					}
					// Get initial mouse position.
					posx = e.clientX;
					posy = e.clientY;
					// Get offset from top left corner.
					let rect = el.getBoundingClientRect();
					xOffset = posx - rect.x;
					yOffset = posy - rect.y;
					// Set ghost size.
					ghost.style.paddingRight = rect.width + 'px';
					ghost.style.height = rect.height + 'px';
					// Show the ghost.
					d_setVisible('ghost', true);
					// And hide the box.
					d_setVisible(id, false);
					// Don't want to be running this code all the time.
					document.onmouseup = close;
					document.onmousemove = drag;
					
					print('clicked box');
				}
				
				function drag(e) {
					e = e || window.event;
					e.preventDefault();
					// Update mouse position.
					posx = e.clientX;
					posy = e.clientY;
					// Move the ghost preview.
					ghost.style.left = (posx - xOffset) + 'px';
					ghost.style.top = (posy - yOffset) + 'px';
					
					print('dragging box');
				}
				
				function close() {
					// Hide the ghost.
					d_setVisible('ghost', false);
					// Show the box.
					d_setVisible(id, true);
					// Set the element's new position.
					el.style.left = (posx - xOffset) + 'px';
					el.style.top = (posy - yOffset) + 'px';
					// Stop doing things when the mouse is released.
					document.onmouseup = null;
					document.onmousemove = null;
					
					print('let go of box');
				}
			}
			
			// Fullscreen | copy-paste
			function requestFullscreen(el) {
				if(el.requestFullscreen)
					el.requestFullscreen();
				else if(el.mozRequestFullScreen)
					el.mozRequestFullScreen();
				else if(el.webkitRequestFullscreen)
					el.webkitRequestFullscreen();
				else if(el.msRequestFullscreen)
					el.msRequestFullscreen();
			}
			
			function exitFullscreen() {
				if(document.exitFullscreen)
					document.exitFullscreen();
				else if(document.mozCancelFullScreen)
					document.mozCancelFullScreen();
				else if(document.webkitExitFullscreen)
					document.webkitExitFullscreen();
				else if(document.msExitFullscreen)
					document.msExitFullscreen();
			}
			
			function isFullscreen() {
				var full_screen_element = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || null;
	
				// If no element is in full-screen
				if (full_screen_element === null) {
					return false;
				}
				else {
					return true;
				}
			}
			
			$('fullscreen').onclick = ()=>{// Fullscreen has to be triggered by a click, idk
				if (isFullscreen()) {
					exitFullscreen();
				}
				else {
					requestFullscreen(document.body);
				}
			}
			
			// File upload and navigation.
			function d_display (img, onload) {
			  if (img === '' || img === undefined) { // Clear the display.
			    $('display').style.backgroundImage = '';
			    
			    if (typeof(onload) === 'function') {
					    onload();
					}
			  }
			  else { // Draw the image.
			    let reader = new FileReader();
				  reader.readAsDataURL(img);
				  reader.onload = (e)=>{
					  let url = e.target.result;
					  $('display').style.backgroundImage = 'url(' + url + ')';
					  // Delay tasks.
					  if (typeof(onload) === 'function') {
					    print('is-function');
					    onload();
					  }
				  };
			  }
			}
			
			{
				let upload = [],  //
				    history = [], //
						pointer = 0,  //
						hidLastImage = false;
			
			  function d_archive(i) {
			    history.unshift(i);
			    return i;
			  }
			  
			  function fetchHistory(pointer) {
			    return upload[history[pointer]];
			  }
			
				function randomIndex() {
					return random(0, upload.length);
				}
				
				function d_displayRandom(onload) {
				  let i = randomIndex();
					d_display(upload[i], onload);
					return i;
				}
				
				function d_displayFilename(img) {
				  let name;
				  if (img === '' || img === undefined) {
				    name = '...';
				  }
				  else {
				    name = img.webkitRelativePath;
				    if (name.length > 66) {
				      name = name.slice(0, 60) + '...' + name.slice(-3);
				    }
				  }
				  $('filename').innerHTML = name;
				}
			
				// When a folder is uploaded, display something to start.
				$('upload').onchange = (e)=>{
					upload = Array.from($('upload').files);
					
					if (upload.length !== 0) {
					  let img = upload[0];
						d_display(img);
						d_displayFilename(img);
						d_archive(0);
					};
					print('upload.onchange()');
					print(upload);
				}
				
				
				$('next').onclick = d_next;
				
				function d_next(e, onload, from) {
				  if (upload.length !== 0) {
				    if (pointer > 0) {
				      d_nextHistory(onload);
				    }
				    else {
				      if (option('display-new') ||
				          from === 'reset' && option('on-end-display-new')) {
				        if (option('hide-every-other')) {
				          if (hidLastImage) {
				            d_nextRandom(onload);
				            hidLastImage = false;
				          }
				          else {
				            d_nextBlank(onload);
				            hidLastImage = true;
				          }
				        }
				        else {
				          d_nextRandom(onload);
				        }
				      }
				      else {
				        if (option('hide-every-other')) {
				          if (hidLastImage) {
				            d_nextIndex(history[1], upload, true, onload);
				            hidLastImage = false;
				          }
				          else {
				            d_nextBlank(onload);
				            hidLastImage = true;
				          }
				        }
				      }
				    }
				  }
				}
				
				function d_nextBlank(onload) {
				  // Display the void.
				  let empty = '';
				  d_display(empty, onload);
				  d_archive(empty);
				  d_displayFilename(empty);
				  print('d_nextBlank()');
				}
				
				function d_nextIndex(i, arr, archive, onload) { // fileorder should make new arr
				  // Display the image at index of arr.
				  let img = arr[i];
				  d_display(img, onload);
				  d_displayFilename(img);
				  if (archive) {
				    d_archive(i);
				  }
				}
				
				function d_nextHistory(onload) {
				  // Display the next image in history.
				  if (pointer > 0) {
				    pointer -= 1;
				    d_nextIndex(history[pointer], upload, false, onload);
				    print('d_nextHistory() active');
				  }
				  else {
				    print('d_nextHistory() inactive');
				  }
				}
				
				function d_nextRandom(onload) {
				  // Display a random image.
				  if (pointer === 0) {
				    let i = d_displayRandom(onload);
				    d_archive(i);
				    d_displayFilename(upload[i]);
				    print('d_nextRandom() active');
				  }
				  else {
				    print('d_nextRandom() inactive');
				  }
				}
				
				$('previous').onclick = ()=>{
				  d_previous();
				}
				
				function d_previous(onload) {
				  if (pointer >= 0 && pointer < (history.length - 1)) {
				    pointer += 1;
				    d_nextIndex(history[pointer], upload, false, onload);
				    print('d_previous() active');
				  }
					else {
						print('d_previous() inactive');
					}
				}
			}
			
			// Keyboard shortcuts.
			{
				let active = true;
				    KEY_NEXT = 'ArrowRight',
						KEY_PREV = 'ArrowLeft';
						
				document.onkeydown = (e)=>{
					if (active) {
						e = e || window.event;
						if (e.key === KEY_NEXT) {
							$('next').click();
						}
						else if (e.key === KEY_PREV) {
							$('previous').click();
						}
					}
					else {
					}
				};
				
				function useKeys (t) {
					return active = t;
				}
				
				function listKeys () {
					s_print('next: ' + KEY_NEXT);
					s_print('prev: ' + KEY_PREV);
				}
			}
			
			// Disable shortcuts when focus is inside a text input.
			{
				let inputs = ['timer-hr', 'timer-min', 'timer-sec'];
				inputs.forEach((id)=>{
					$(id).onfocus = ()=>{ // Why does addEventListener not work here?
						useKeys(false);
					}
					$(id).onblur = ()=>{
						useKeys(true);
					}
				});
			}
			
			// -------- Run the following on <startup>: ------------------------
			printTest(true);
			
			// In case they're reloading the page.
			$('upload').onchange();
			
			// -----------------------------------------------------------------
			
			
			
			// ---------------------- End --------------------------------------
			
			// TODO
			// Prevent repeats
			// Image preloading
			// ivconfig.txt + Image tags
		</script>
  </body>
</html>
